@page "/game"
@inject IJSRuntime JS
@inject NavigationManager Navigation

<PageTitle>PoReflex - Game</PageTitle>

<div class="game-container" data-testid="game-container">
    @* Game Stage - 85% of viewport *@
    <div class="game-stage">
        <canvas id="game-canvas" data-testid="game-canvas"></canvas>

        @if (gameState == GameState.Completed)
        {
            <div class="result-overlay" data-testid="result-overlay">
                <h2>COMPLETE!</h2>
                <p class="average-time" data-testid="average-time">@averageMs.ToString("F2")ms</p>
                <p class="result-label">Average Reaction Time</p>
                <div class="reaction-times">
                    @for (int i = 0; i < reactionTimes.Length; i++)
                    {
                        <span class="time-badge">@((i + 1)): @reactionTimes[i].ToString("F2")ms</span>
                    }
                </div>
                <button class="btn-submit" @onclick="SubmitScore">Submit Score</button>
            </div>
        }

        @if (gameState == GameState.Failed)
        {
            <div class="failure-overlay" data-testid="failure-overlay">
                <h2 class="failure-title" data-testid="failure-message">@failureReason</h2>
                <p class="failure-detail">@failureDetail</p>
                <button class="btn-retry" @onclick="ReturnHome">Try Again</button>
            </div>
        }
    </div>

    @* Control Zone - 15% of viewport *@
    <div class="control-zone">
        @if (gameState == GameState.Completed || gameState == GameState.Failed)
        {
            <button class="menu-button" @onclick="ReturnHome" data-testid="menu-button">
                <span class="menu-text">MAIN MENU</span>
            </button>
        }
        else
        {
            <StopButton OnStop="HandleStop" Disabled="@(!isPlaying)" />
        }
    </div>
</div>

@code {
    [Parameter]
    [SupplyParameterFromQuery]
    public string? Nickname { get; set; }

    private enum GameState { Idle, Playing, Completed, Failed }
    private GameState gameState = GameState.Idle;
    private bool isPlaying = false;

    private double[] reactionTimes = Array.Empty<double>();
    private double averageMs = 0;
    private string failureReason = "";
    private string failureDetail = "";

    private DotNetObjectReference<Game>? dotNetRef;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Validate nickname
            if (string.IsNullOrWhiteSpace(Nickname))
            {
                Navigation.NavigateTo("/");
                return;
            }

            dotNetRef = DotNetObjectReference.Create(this);

            // Initialize game engine
            await JS.InvokeVoidAsync("GameEngine.init", "game-canvas");

            // Initialize audio (requires user interaction first)
            await JS.InvokeVoidAsync("AudioSynth.init");

            // Start the game
            await StartGame();
        }
    }

    private async Task StartGame()
    {
        gameState = GameState.Playing;
        isPlaying = true;
        StateHasChanged();

        // Resume audio context
        await JS.InvokeVoidAsync("AudioSynth.resume");

        // Start game with callbacks
        await JS.InvokeVoidAsync("eval", $@"
            GameEngine.startGame({{
                onComplete: (result) => DotNet.invokeMethodAsync('Po.Reflex.Client', 'OnGameComplete', result),
                onFailed: (result) => DotNet.invokeMethodAsync('Po.Reflex.Client', 'OnGameFailed', result),
                onBarStopped: (barNum, time) => DotNet.invokeMethodAsync('Po.Reflex.Client', 'OnBarStopped', barNum, time)
            }});
        ");
    }

    private async Task HandleStop()
    {
        if (isPlaying)
        {
            await JS.InvokeVoidAsync("GameEngine.handleStop");
            await JS.InvokeVoidAsync("AudioSynth.playStopBeep");
        }
    }

    [JSInvokable("OnGameComplete")]
    public static async Task OnGameCompleteStatic(GameResult result)
    {
        // This will be handled through events in production
        // For now, we use instance method via different approach
    }

    [JSInvokable("OnGameFailed")]
    public static async Task OnGameFailedStatic(FailureResult result)
    {
        // This will be handled through events in production
    }

    [JSInvokable("OnBarStopped")]
    public static async Task OnBarStoppedStatic(int barNumber, double reactionTime)
    {
        // This will be handled through events in production
    }

    // Instance method called from JS
    [JSInvokable]
    public void GameComplete(double[] times, double average)
    {
        reactionTimes = times;
        averageMs = average;
        gameState = GameState.Completed;
        isPlaying = false;
        StateHasChanged();
    }

    [JSInvokable]
    public void GameFailed(string reason, string detail)
    {
        failureReason = reason;
        failureDetail = detail;
        gameState = GameState.Failed;
        isPlaying = false;
        StateHasChanged();
    }

    private async Task SubmitScore()
    {
        // Navigate to home with score submission
        Navigation.NavigateTo($"/?submitted=true&nickname={Uri.EscapeDataString(Nickname ?? "")}&average={averageMs}");
    }

    private void ReturnHome()
    {
        Navigation.NavigateTo("/");
    }

    public void Dispose()
    {
        dotNetRef?.Dispose();
        _ = JS.InvokeVoidAsync("GameEngine.stop");
    }

    // DTOs for JS interop
    public record GameResult(double[] ReactionTimes, double AverageMs);
    public record FailureResult(string Reason, string Detail);
}
